Server.java
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;

public class Server {
    public static void main(String[] args) {
        try {
            Impl obj = new Impl();
            Registry registry = LocateRegistry.createRegistry(1099);
            registry.rebind("FacebookService", obj);
            System.out.println("Facebook Server is ready. Please launch Client.java to use Facebook");
        } catch (RemoteException e) {
            System.err.println("Server exception: " + e.toString());
        }
    }
}

Client.java
import java.io.IOException;
import java.rmi.NotBoundException;
import java.rmi.RemoteException;
import java.rmi.registry.LocateRegistry;
import java.rmi.registry.Registry;
import java.util.List;
import java.util.Scanner;

public class Client {
    private Service service;
    private ClientCallback callback;
    private String currentUser = null;
    private Scanner scanner = new Scanner(System.in);

    public Client() {
        try {
            Registry registry = LocateRegistry.getRegistry(null, 1099);
            service = (Service) registry.lookup("FacebookService");
            callback = new ClientCallbackImpl();
        }
        catch (NotBoundException | RemoteException e) {
        }
    }

    private void cls() throws RemoteException {
        try {
            if (System.getProperty("os.name").contains("Windows")) new ProcessBuilder("cmd", "/c", "cls").inheritIO().start().waitFor();
            else new ProcessBuilder("clear").inheritIO().start().waitFor();
        }
        catch (IOException | InterruptedException e) {}
    }

    public void start() {
        while (true) {
            if (currentUser == null) 
                showLoginMenu();
            else 
                showMainMenu();
        }
    }

    private void sendFriendRequest() throws RemoteException {
        System.out.print("Enter username to send friend request: ");
        String friend = scanner.nextLine();
        cls();
        if (service.sendFriendRequest(currentUser, friend)) System.out.println("Friend request to " + friend + " sent successfully!");
        else System.out.println("Fail to send friend request - user '" + friend + "' does not exist!");
    }

    private void showLoginMenu() {
        System.out.println("\n=== Facebook ===");
        System.out.println("1. Login\n2. Register\n3. Exit");
        System.out.print("Choose option: ");
        try {
            int choice = scanner.nextInt();
            scanner.nextLine();
            switch (choice) {
                case 1 -> login();
                case 2 -> register();
                case 3 -> System.exit(0);
            }
        }
        catch (Exception e) {
            System.err.println("Error: Please enter integer ranging from 1 to 3 only!");
            scanner.nextLine();
        }
    }

    private void login() {
        try {
            System.out.print("Username: ");
            String username = scanner.nextLine();
            System.out.print("Password: ");
            String password = scanner.nextLine();
            cls();
            if (service.login(username, password, callback)) {
                currentUser = username;
                System.out.println("Login successful!");
            }
            else System.out.println("Login failed!");
        }
        catch (RemoteException e) {
            System.err.println("Login error: " + e.getMessage());
        }
    }

    private void register() {
        try {
            System.out.print("Username: ");
            String username = scanner.nextLine();
            System.out.print("Password: ");
            String password = scanner.nextLine();
            System.out.print("Email: ");
            String email = scanner.nextLine();
            System.out.print("Phone Number: ");
            String phone = scanner.nextLine();
            cls();
            if (service.register(username, password)) System.out.println("Registration successful! Your username will be used to communicate with friends in the application.");
            else System.out.println("Registration failed - username already exist!");
        }
        catch (RemoteException e) {
            System.err.println("Registration error: " + e.getMessage());
        }
    }

    private void showMainMenu() {
        try {
            System.out.println("===================================================");
            System.out.println("                 Welcome " + currentUser);
            System.out.println("    Feibook wishes you a Happy Merry Christmas!");
            System.out.println("===================================================");
            System.out.println("1. Create Post\n2. View News Feed\n3. Send Friend Request\n4. View Friend Requests (" + service.getPendingFriendRequests(currentUser).size() + ")\n5. View Friends\n6. Send Message\n7. View Messages\n8. View Notifications\n9. Manage Posts\n10. Logout");
            System.out.print("Choose option: ");
            int choice = scanner.nextInt();
            scanner.nextLine();
            switch (choice) {
                case 1 -> createPost();
                case 2 -> viewNewsFeed();
                case 3 -> sendFriendRequest();
                case 4 -> viewFriendRequests();
                case 5 -> viewFriends();
                case 6 -> sendMessage();
                case 7 -> viewMessages();
                case 8 -> viewNotifications();
                case 9 -> managePosts();
                case 10 -> logout();
                default -> System.out.println("Invalid option!");
            }
        }
        catch (RemoteException e) {
            System.err.println("Error: Please enter integer ranging from 1 to 10 only!");
            scanner.nextLine();
        }
    }

    private void viewFriendRequests() throws RemoteException {
        cls();
        List<String> requests = service.getPendingFriendRequests(currentUser);
        if (requests.isEmpty()) {
            System.out.println("No pending friend requests!");
            return;
        }
        System.out.println("\n=== Friend Requests ===");
        for (String requester : requests) {
            System.out.println("From: " + requester);
            System.out.println("1. Accept\n2. Reject\n3. Skip");
            System.out.print("Choose option: ");
            int choice = scanner.nextInt();
            scanner.nextLine();
            switch (choice) {
                case 1 -> {
                    if (service.acceptFriendRequest(currentUser, requester)) System.out.println("Friend request accepted!");
                }
                case 2 -> {
                    if (service.rejectFriendRequest(currentUser, requester)) System.out.println("Friend request rejected!");
                }
            }
        }
    }

    private void viewNotifications() throws RemoteException {
        cls();
        List<String> notifications = service.getNotifications(currentUser);
        if (notifications.isEmpty()) {
            cls();
            System.out.println("No notifications!");
            return;
        }
        System.out.println("\n=== Notifications ===");
        for (String notification : notifications) System.out.println(notification);
    }
    
    private void managePosts() throws RemoteException {
        cls();
        List<Post> userPosts = service.getUserPosts(currentUser);
        if (userPosts.isEmpty()) {
            System.out.println("You haven't created any posts yet!");
            return;
        }
        for (Post post : userPosts) {
            System.out.println("\n=== Post ===");
            System.out.println("ID: " + post.id + "\nContent: " + post.content + "\nLikes: " + post.likes.size() + "\nComments: " + post.comments.size());
            System.out.println("\n1. Edit\n2. Delete\n3. Next post\n4. Return to menu");
            System.out.print("Choose option: ");
            int choice = scanner.nextInt();
            scanner.nextLine();
            switch (choice) {
                case 1 -> {
                    System.out.print("Enter new content: ");
                    String newContent = scanner.nextLine();
                    cls();
                    if (service.editPost(currentUser, post.id, newContent)) System.out.println("Post updated successfully!");
                    else System.out.println("Failed to update post!");
                }
                case 2 -> {
                    cls();
                    if (service.deletePost(currentUser, post.id)) System.out.println("Post deleted successfully!");
                    else System.out.println("Failed to delete post!");
                }
                case 3 -> {
                    cls();
                    continue;
                }
                case 4 -> {
                    cls();
                    return;
                }
            }
        }
    }

    private void createPost() throws RemoteException {
        cls();
        System.out.print("Enter post content: ");
        String content = scanner.nextLine();
        int postId = service.createPost(currentUser, content);
        System.out.println("Post created with ID: " + postId);
    }

    private void viewNewsFeed() throws RemoteException {
        cls();
        List<Post> newsFeed = service.getNewsFeed(currentUser);
        if (newsFeed.isEmpty()) {
            System.out.println("No posts in news feed!");
            return;
        }
        for (Post post : newsFeed) {
            System.out.println("\n=== Post ===" + "\nFrom: " + post.username + "\nContent: " + post.content + "\nLikes: " + post.likes.size() + "\nComments: " + post.comments.size());
            System.out.println("\n=== Comments ===");
            if (post.comments.isEmpty()) System.out.println("No comments yet");
            else for (Comment comment : post.comments) System.out.println(comment.username + ": " + comment.content);
            System.out.println("\n=== Options ===\n1. Like\n2. Comment\n3. Next post\n4. Return to menu");
            System.out.print("Choose option: ");
            int action = scanner.nextInt();
            scanner.nextLine();
            switch (action) {
                case 1 -> {
                    service.likePost(currentUser, post.id);
                    cls();
                    System.out.println("Post liked!");
                }
                case 2 -> {
                    System.out.print("Enter comment: ");
                    String comment = scanner.nextLine();
                    service.commentPost(currentUser, post.id, comment);
                    cls();
                    System.out.println("Comment added!");
                }
                case 3 -> {
                    cls();
                    continue;
                }
                case 4 -> {
                    cls();
                    return;
                }
            }
        }
        cls();
    }

    private void viewFriends() throws RemoteException {
        cls();
        List<String> friends = service.getFriendList(currentUser);
        if (friends.isEmpty()) {
            System.out.println("No friends yet!");
            return;
        }
        System.out.println("=== Friends ===");
        for (String friend : friends) System.out.println("- " + friend);
        System.out.println("\n");
    }

    private void sendMessage() throws RemoteException {
        cls();
        System.out.print("Enter recipient's username: ");
        String to = scanner.nextLine();
        System.out.print("Enter message: ");
        String message = scanner.nextLine();
        cls();
        if (service.sendMessage(currentUser, to, message)) System.out.println("Message sent successfully!");
        else System.out.println("Failed to send message - user does not exist!");
    }

    private void viewMessages() throws RemoteException {
        cls();
        List<String> friends = service.getFriendList(currentUser);
        if (friends.isEmpty()) {
            System.out.println("You have no friends to chat with! So sad :(");
            return;
        }
        while (true) {
            cls();
            System.out.println("\n=== Select friend to view conversation ===");
            for (int i = 0; i < friends.size(); i++)
                System.out.println((i + 1) + ". " + friends.get(i));
            System.out.println((friends.size() + 1) + ". Return to menu\nChoose friend:");            
            try {
                int choice = scanner.nextInt();
                scanner.nextLine();
                cls();
                if (choice == friends.size() + 1) {cls(); return;}
                if (choice > friends.size()) {
                    System.out.println("Invalid choice! Please try again!");
                    continue;
                }
                String friend = friends.get(choice - 1);
                displayConversation(friend);
            }
            catch (RemoteException e) {
                System.err.println("Error: Please enter integer ranging from 1 to " + (friends.size() + 1) + " only!");
                scanner.nextLine();
            }
        }
    }

    private void displayConversation(String friend) throws RemoteException {
        while (true) {
            List<Message> messages = service.getMessages(currentUser, friend);
            System.out.println("\n=== Conversation with " + friend + " ===");
            if (messages.isEmpty()) System.out.println("No messages yet!");
            else {
                for (Message msg : messages) {
                    String prefix = msg.from.equals(currentUser) ? "You" : friend;
                    System.out.println(prefix + ": " + msg.content);
                }
            }
            System.out.println("\n1. Send message\n2. Return to friend list\nChoose option:");
            int choice = scanner.nextInt();
            scanner.nextLine();
            cls();          
            if (choice == 1) {
                System.out.print("Enter message: ");
                String message = scanner.nextLine();
                if (service.sendMessage(currentUser, friend, message)) System.out.println("Message sent successfully!");
                else System.out.println("Failed to send message!");
            }
            else return;
        }
    }

    private void logout() throws RemoteException {
        service.logout(currentUser);
        currentUser = null;
        cls();
        System.out.println("Logged out successfully!");
    }

    public static void main(String[] args) {
        Client client = new Client();
        client.start();
    }
}

ClientCallback.java
import java.rmi.Remote;
import java.rmi.RemoteException;

interface ClientCallback extends Remote {
    void notifyNewMessage(String from, String message) throws RemoteException;
    void notifyNewPost(String from, String content) throws RemoteException;
    void notifyNewNotification(String notification) throws RemoteException;
}

ClientCallbackImpl.java
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;

public class ClientCallbackImpl extends UnicastRemoteObject implements ClientCallback {
    private static final long serialVersionUID = 1L;
    
    public ClientCallbackImpl() throws RemoteException {
        super();
    }
    
    @Override
    public void notifyNewMessage(String from, String message) throws RemoteException {
        System.out.println("\n\n[NEW MESSAGE from " + from + "]: " + message);
        System.out.print("\nEnter choice: ");
    }
    
    @Override
    public void notifyNewPost(String from, String content) throws RemoteException {
        System.out.println("\n\n[NEW POST from " + from + "]: " + content);
        System.out.print("\nEnter choice: ");
    }
    
    @Override
    public void notifyNewNotification(String notification) throws RemoteException {
        System.out.println("\n\n[NOTIFICATION]: " + notification);
        System.out.print("\nEnter choice: ");
    }
}

Service.java
import java.rmi.Remote;
import java.rmi.RemoteException;
import java.util.ArrayList;
import java.util.List;

interface Service extends Remote {
    boolean register(String username, String password) throws RemoteException;
    boolean login(String username, String password, ClientCallback callback) throws RemoteException;
    boolean sendMessage(String from, String to, String content) throws RemoteException;
    boolean deletePost(String username, int postId) throws RemoteException;
    boolean editPost(String username, int postId, String newContent) throws RemoteException;
    boolean sendFriendRequest(String from, String to) throws RemoteException;
    boolean acceptFriendRequest(String username, String requester) throws RemoteException;
    boolean rejectFriendRequest(String username, String requester) throws RemoteException;
    
    List<String> getFriendList(String username) throws RemoteException;
    List<Post> getNewsFeed(String username) throws RemoteException;
    List<Message> getMessages(String username, String friend) throws RemoteException;
    List<String> getNotifications(String username) throws RemoteException;
    List<String> getPendingFriendRequests(String username) throws RemoteException;
    List<Post> getUserPosts(String username) throws RemoteException;
    
    int createPost(String username, String content) throws RemoteException;

    void logout(String username) throws RemoteException;
    void likePost(String username, int postId) throws RemoteException;
    void commentPost(String username, int postId, String comment) throws RemoteException;
}

class Post implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    int id;
    String username;
    String content;
    List<String> likes = new ArrayList<>();
    List<Comment> comments = new ArrayList<>();
    long timestamp;
    
    Post(int id, String username, String content) {
        this.id = id;
        this.username = username;
        this.content = content;
        this.timestamp = System.currentTimeMillis() + (8 * 60 * 60 * 1000);
    }
}

class Comment implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    String username;
    String content;
    
    Comment(String username, String content) {
        this.username = username;
        this.content = content;
    }
}

class Message implements java.io.Serializable {
    private static final long serialVersionUID = 1L;
    String from;
    @SuppressWarnings("unused")
    String to;
    String content;
    long timestamp;
    
    Message(String from, String to, String content, long timestamp) {
        this.from = from;
        this.to = to;
        this.content = content;
        this.timestamp = timestamp;
    }
}

Impl.java
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.rmi.RemoteException;
import java.rmi.server.UnicastRemoteObject;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.stream.Collectors;

public class Impl extends UnicastRemoteObject implements Service {
    @SuppressWarnings("FieldMayBeFinal")
    private Map<String, ClientCallback> activeClients = new ConcurrentHashMap<>();
    @SuppressWarnings("FieldMayBeFinal")
    private Map<String, Set<String>> friends;
    @SuppressWarnings("FieldMayBeFinal")
    private Map<String, List<Post>> posts;
    @SuppressWarnings("FieldMayBeFinal")
    private Map<String, List<String>> notifications;
    public static int nextPostId = 5;
    @SuppressWarnings("FieldMayBeFinal")
    private Map<String, List<String>> pendingFriendRequests;
    
    public Impl() throws RemoteException {
        super();
        friends = new ConcurrentHashMap<>();
        posts = new ConcurrentHashMap<>();
        notifications = new ConcurrentHashMap<>();
        pendingFriendRequests = new ConcurrentHashMap<>();
        loadAllUserPosts();
    }

    private void loadAllUserPosts() {
        try {
            Path usersPath = Paths.get("facebook_data/users.txt");
            if (Files.exists(usersPath)) {
                List<String> users = Files.lines(usersPath).map(line -> line.split(":")[0]).collect(Collectors.toList());                
                for (String username : users) {posts.put(username, new ArrayList<>(DatabaseManager.loadPosts(username)));}
            }
        }
        catch (IOException e) {System.err.println("Error loading user posts: " + e.getMessage());}
    }
    
    @Override
    public boolean register(String username, String password) throws RemoteException {
        System.out.println("[LOG] Processing register request for user " + username);
        if (DatabaseManager.userExists(username)) return false;
        boolean success = DatabaseManager.saveUser(username, password);
        if (success) {
            friends.put(username, new HashSet<>());
            posts.put(username, new ArrayList<>());
            notifications.put(username, new ArrayList<>());
        }
        return success;
    }
    
    @Override
    public boolean login(String username, String password, ClientCallback callback) throws RemoteException {
        System.out.println("[LOG] Processing login request for user " + username);
        if (DatabaseManager.verifyUser(username, password)) {
            activeClients.put(username, callback);
            friends.put(username, new HashSet<>(DatabaseManager.loadFriends(username)));
            if (!posts.containsKey(username)) posts.put(username, new ArrayList<>(DatabaseManager.loadPosts(username)));
            notifications.put(username, new ArrayList<>(DatabaseManager.loadNotifications(username)));
            pendingFriendRequests.put(username, new ArrayList<>(DatabaseManager.loadFriendRequests(username)));
            return true;
        }
        return false;
    }

    @Override
    public boolean sendMessage(String from, String to, String content) throws RemoteException {
        System.out.println("[LOG] Processing sendMessage request for user " + from + " to " + to);
        if (!DatabaseManager.userExists(to)) return false;
        DatabaseManager.saveConversation(from, to, content);
        DatabaseManager.saveNotification(to, "New message from " + from + ": " + (content.length() > 50 ? content.substring(0, 47) + "..." : content));
        ClientCallback recipient = activeClients.get(to);
        if (recipient != null) recipient.notifyNewMessage(from, content);
        return true;
    }

    @Override
    public boolean deletePost(String username, int postId) throws RemoteException {
        System.out.println("[LOG] Processing deletePost request for user " + username);
        List<Post> userPosts = posts.get(username);
        if (userPosts != null) {
            boolean removed = userPosts.removeIf(post -> post.id == postId);
            if (removed) {
                DatabaseManager.deletePost(username, postId);
                return true;
            }
        }
        return false;
    }
    
    @Override
    public boolean editPost(String username, int postId, String newContent) throws RemoteException {
        System.out.println("[LOG] Processing editPost request for user " + username);
        List<Post> userPosts = posts.get(username);
        if (userPosts != null) {
            for (Post post : userPosts) {
                if (post.id == postId) {
                    post.content = newContent;
                    DatabaseManager.updatePost(username, post);
                    return true;
                }
            }
        }
        return false;
    }

    @Override
    public boolean sendFriendRequest(String from, String to) throws RemoteException {
        System.out.println("[LOG] Processing sendFriendRequest request for user " + from + " to " + to);
        if (!DatabaseManager.userExists(to)) return false;
        DatabaseManager.saveFriendRequest(from, to);
        DatabaseManager.saveNotification(to, from + " sent you a friend request");
        ClientCallback recipientCallback = activeClients.get(to);
        if (recipientCallback != null) recipientCallback.notifyNewNotification(from + " sent you a friend request");
        return true;
    }

    @Override
    public boolean acceptFriendRequest(String username, String requester) throws RemoteException {
        System.out.println("[LOG] Processing acceptFriendRequest request for user " + username);
        List<String> requests = DatabaseManager.loadFriendRequests(username);
        if (requests.contains(requester)) {
            friends.get(username).add(requester);
            friends.get(requester).add(username);
            DatabaseManager.saveFriend(username, requester);
            DatabaseManager.saveFriend(requester, username);
            DatabaseManager.removeFriendRequest(username, requester);
            DatabaseManager.saveNotification(requester, username + " accepted your friend request");
            ClientCallback requesterCallback = activeClients.get(requester);
            if (requesterCallback != null) requesterCallback.notifyNewNotification(username + " accepted your friend request");
            return true;
        }
        return false;
    }
    
    @Override
    public boolean rejectFriendRequest(String username, String requester) throws RemoteException {
        System.out.println("[LOG] Processing rejectFriendRequest request for user " + username);
        DatabaseManager.removeFriendRequest(username, requester);
        return true;
    }

    @Override
    public List<String> getFriendList(String username) throws RemoteException {
        System.out.println("[LOG] Processing getFriendList request for user " + username);
        return new ArrayList<>(friends.get(username));
    }

    @Override
    public List<Post> getNewsFeed(String username) throws RemoteException {
        try {
            System.out.println("[LOG] Processing getNewsFeed request for user " + username);
            List<Post> newsFeed = new ArrayList<>();
            Set<String> userFriends = friends.get(username);
            for (String friend : userFriends) newsFeed.addAll(posts.get(friend));
            newsFeed.sort((p1, p2) -> p2.id - p1.id);
            
            return newsFeed;
        }
        catch (Exception e) {
            return new ArrayList<>();
        }
    }

    @Override
    public List<Message> getMessages(String username, String friend) throws RemoteException {
        System.out.println("[LOG] Processing getMessages request for user " + username + " from " + friend);
        return DatabaseManager.loadConversation(username, friend);
    }

    @Override
    public List<String> getNotifications(String username) throws RemoteException {
        System.out.println("[LOG] Processing getNotifications request for user " + username);
        return DatabaseManager.loadNotifications(username);
    }
    
    @Override
    public List<String> getPendingFriendRequests(String username) throws RemoteException {
        System.out.println("[LOG] Processing getPendingFriendRequests request for user " + username);
        return DatabaseManager.loadFriendRequests(username);
    }

    @Override
    public List<Post> getUserPosts(String username) throws RemoteException {
        System.out.println("[LOG] Processing getUserPosts request for user " + username);
        return posts.getOrDefault(username, new ArrayList<>());
    }

    @Override
    public int createPost(String username, String content) throws RemoteException {
        System.out.println("[LOG] Processing createPost request for user " + username);
        Post post = new Post(nextPostId++, username, content);
        posts.computeIfAbsent(username, k -> new ArrayList<>()).add(post);
        DatabaseManager.savePost(username, post);
        try {
            for (String friend : friends.get(username)) {
                DatabaseManager.saveNotification(friend, username + " created a new post: " + (content.length() > 50 ? content.substring(0, 47) + "..." : content));
                ClientCallback friendCallback = activeClients.get(friend);
                if (friendCallback != null) friendCallback.notifyNewPost(username, content);
            }
        }
        catch (RemoteException e) {}
        return post.id;
    }

    @Override
    public void logout(String username) throws RemoteException {
        System.out.println("[LOG] Logging out user " + username);
        activeClients.remove(username);
    }

    @Override
    public void likePost(String username, int postId) throws RemoteException {
        System.out.println("[LOG] Processing likePost request for user " + username);
        for (List<Post> userPosts : posts.values()) {
            for (Post post : userPosts) {
                if (post.id == postId) {
                    if (post.likes.contains(username)) return;
                    post.likes.add(username);
                    DatabaseManager.updatePost(post.username, post);
                    DatabaseManager.saveNotification(post.username, username + " liked your post");
                    ClientCallback ownerCallback = activeClients.get(post.username);
                    if (ownerCallback != null) ownerCallback.notifyNewNotification(username + " liked your post");
                    return;
                }
            }
        }
    }
    
    @Override
    public void commentPost(String username, int postId, String comment) throws RemoteException {
        System.out.println("[LOG] Processing commentPost request for user " + username);
        if (comment == null || comment.trim().isEmpty()) {
            System.out.println("Error: Comment cannot be empty.");
            return;
        }
        for (List<Post> userPosts : posts.values()) {
            for (Post post : userPosts) {
                if (post.id == postId) {
                    post.comments.add(new Comment(username, comment));
                    DatabaseManager.updatePost(post.username, post);
                    DatabaseManager.saveNotification(post.username, username + " commented on your post");
                    ClientCallback ownerCallback = activeClients.get(post.username);
                    if (ownerCallback != null) ownerCallback.notifyNewNotification(username + " commented on your post");
                    return;
                }
            }
        }
    }
}

DatabaseManager.java
import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.stream.Collectors;

class DatabaseManager {
    private static final String DATA_DIR = "facebook_data/";
    
    static {
        new File(DATA_DIR).mkdirs();
    }

    private static class TimestampedNotification {
        long timestamp;
        String notification;
        TimestampedNotification(long timestamp, String notification) {
            this.timestamp = timestamp;
            this.notification = notification;
        }
    }
    
    static boolean saveUser(String username, String password) {
        try {
            Files.write(Paths.get(DATA_DIR + "users.txt"), (username + ":" + password + "\n").getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);

            return true;
        }
        catch (IOException e) {}
        return false;
    }

    static boolean userExists(String username) {
        try {return Files.lines(Paths.get(DATA_DIR + "users.txt")).anyMatch(line -> line.split(":")[0].equals(username));}
        catch (IOException e) {return false;}
    }
    
    static boolean verifyUser(String username, String password) {
        try {return Files.lines(Paths.get(DATA_DIR + "users.txt")).anyMatch(line -> line.equals(username + ":" + password));}
        catch (IOException e) {return false;}
    }

    static void saveFriend(String username, String friend) {
        try {Files.write(Paths.get(DATA_DIR + username + "_friends.txt"), (friend + "\n").getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);}
        catch (IOException e) {}
    }

    static Set<String> loadFriends(String username) {
        Set<String> friends = new HashSet<>();
        try {
            Path path = Paths.get(DATA_DIR + username + "_friends.txt");
            if (Files.exists(path)) Files.lines(path).forEach(friends::add);
        }
        catch (IOException e) {}
        return friends;
    }
    
    static void savePost(String username, Post post) {
        try {
            String postData = post.id + ":" + post.timestamp + ":" + post.content + "\n";
            Files.write(Paths.get(DATA_DIR + username + "_posts.txt"), postData.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        }
        catch (IOException e) {}
    }
    
    static List<Post> loadPosts(String username) {
        List<Post> posts = new ArrayList<>();
        try {
            Path path = Paths.get(DATA_DIR + username + "_posts.txt");
            if (Files.exists(path)) {
                Files.lines(path).forEach(line -> {
                    String[] parts = line.split(":", 3);
                    if (parts.length == 3) {
                        Post post = new Post(Integer.parseInt(parts[0]), username, parts[2]);
                        post.timestamp = Long.parseLong(parts[1]);
                        posts.add(post);
                    }
                });
            }
        }
        catch (IOException e) {}
        return posts;
    }

    static void saveConversation(String sender, String receiver, String content) {
        try {
            String message = (System.currentTimeMillis() + (8 * 60 * 60 * 1000)) + ":" + sender + ":" + content + "\n";
            String conversationFile = getConversationFileName(sender, receiver);            
            Files.write(Paths.get(DATA_DIR + conversationFile), message.getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        }
        catch (IOException e) {}
    }

    static List<Message> loadConversation(String user1, String user2) {
        List<Message> messages = new ArrayList<>();
        try {
            String conversationFile = getConversationFileName(user1, user2);
            Path path = Paths.get(DATA_DIR + conversationFile);
            if (Files.exists(path)) {
                List<String> lines = Files.readAllLines(path);
                for (String line : lines) {
                    String[] parts = line.split(":", 3);
                    if (parts.length == 3) {
                        long timestamp = Long.parseLong(parts[0]);
                        String sender = parts[1];
                        String content = parts[2];
                        messages.add(new Message(sender, sender.equals(user1) ? user2 : user1, content, timestamp));
                    }
                }
                messages.sort((m1, m2) -> Long.compare(m1.timestamp, m2.timestamp));
            }
        }
        catch (IOException e) {}
        return messages;
    }

    static void updatePost(String username, Post post) {
        Path path = Paths.get(DATA_DIR + username + "_posts.txt");
        List<String> updatedPosts = new ArrayList<>();
    
        try {
            if (Files.exists(path)) {
                List<String> lines = Files.readAllLines(path);
                for (String line : lines) {
                    String[] parts = line.split(":", 2); 
                    if (parts.length < 2) continue;
                    int postId = Integer.parseInt(parts[0]);
                    if (postId == post.id) {
                        String updatedPost = post.id + ":" + post.timestamp + ":" + post.content + "\n";
                        updatedPosts.add(updatedPost);
                    }
                    else updatedPosts.add(line + "\n");
                }    
                Files.write(path, updatedPosts, StandardOpenOption.WRITE, StandardOpenOption.TRUNCATE_EXISTING);
            }
        }
        catch (IOException e) {}
    }

    static void saveFriendRequest(String from, String to) {
        try {
            String requestFile = DATA_DIR + to + "_friendRequests.txt";
            if (Files.exists(Paths.get(requestFile))) {
                List<String> requests = Files.readAllLines(Paths.get(requestFile));
                if (requests.contains(from)) return;
            }
            Files.write(Paths.get(requestFile), (from + "\n").getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        }
        catch (IOException e) {}
    }

    static List<String> loadFriendRequests(String username) {
        List<String> requests = new ArrayList<>();
        try {
            Path path = Paths.get(DATA_DIR + username + "_friendRequests.txt");
            if (Files.exists(path)) requests = Files.readAllLines(path);
        }
        catch (IOException e) {}
        return requests;
    }
        
    static void removeFriendRequest(String to, String from) {
        try {
            String requestFile = DATA_DIR + to + "_friendRequests.txt";
            if (Files.exists(Paths.get(requestFile))) {
                List<String> requests = Files.readAllLines(Paths.get(requestFile));
                requests.remove(from);
                Files.write(Paths.get(requestFile), requests, StandardOpenOption.TRUNCATE_EXISTING);
            }
        }
        catch (IOException e) {}
    }
    
    static void saveNotification(String username, String notification) {
        try {
            String notificationFile = DATA_DIR + username + "_notifications.txt";
            Files.write(Paths.get(notificationFile), ((System.currentTimeMillis() + (8 * 60 * 60 * 1000)) + ":" + notification + "\n").getBytes(), StandardOpenOption.CREATE, StandardOpenOption.APPEND);
        }
        catch (IOException e) {}
    }

    static List<String> loadNotifications(String username) {
        List<String> notifications = new ArrayList<>();
        try {
            Path path = Paths.get(DATA_DIR + username + "_notifications.txt");
            if (Files.exists(path)) {
                List<String> lines = Files.readAllLines(path);
                List<TimestampedNotification> timestampedNotifications = new ArrayList<>();                
                for (String line : lines) {
                    String[] parts = line.split(":", 2);
                    if (parts.length == 2) {
                        long timestamp = Long.parseLong(parts[0]);
                        String notification = parts[1];
                        timestampedNotifications.add(new TimestampedNotification(timestamp, notification));
                    }
                }
                timestampedNotifications.sort((n1, n2) -> Long.compare(n2.timestamp, n1.timestamp));
                for (TimestampedNotification tn : timestampedNotifications) {
                    java.util.Date date = new java.util.Date(tn.timestamp);
                    java.text.SimpleDateFormat sdf = new java.text.SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
                    notifications.add("[" + sdf.format(date) + "] " + tn.notification);
                }
            }
        }
        catch (IOException e) {}
        return notifications;
    }
    
    static boolean deletePost(String username, int postId) {
        Path path = Paths.get(DATA_DIR + username + "_posts.txt");
        try {
            if (Files.exists(path)) {
                List<String> posts = Files.readAllLines(path);
                List<String> updatedPosts = posts.stream().filter(line -> !line.startsWith(postId + ":")).collect(Collectors.toList());
                Files.write(path, updatedPosts, StandardOpenOption.TRUNCATE_EXISTING);
                return true;
            }
        }
        catch (IOException e) {}
        return false;
    }
    
    private static String getConversationFileName(String user1, String user2) {
        return (user1.compareTo(user2) < 0) ? user1 + "_" + user2 + "_conversation.txt" : user2 + "_" + user1 + "_conversation.txt";
    }
}

Write me a assignment report for this project. It is about a distributed system application prototype for Facebook. Please include any diagram if possible in the report. Also, explain the overview and objective of this prototype, simple introduction to Java RMI and how it is being implemented in the program. You should also include project file structure and function names. Explain the key features and functionality of this program.

The project code can be classify by usage:
1) User
 - Log In
 - Register
 - Add Friend by sending friend request
 - Accept / Reject friend request
 - View Friend List
2) Post
 - Create
 - Edit / Delete
 - Like
 - Add Comment
3) NewsFeed
 - Load News Feed
4) Messaging
 - Send Message
 - Receive / Load Message
5) Notification
 - Receive notification
 - Generate Notification (notifyNewMessage, notifyNewPost & notifyNewNotification)

Database used is plain text file for this prototype. You may use bullet point, paragrapah-style writing. The report may not be too lengthy or too short.

You should structure the report in this sequence:
1) Overview and objectives of the project.
2) Visual representations using Diagram (MULTIPLE Use Case diagrams)
3) Project File Structure, Function Names
4) Simple introduction to Java RMI 
5) Description of the developed prototype, including key features and functionality.
6) How Java RMI is being implemented in the program
7) Conclusion